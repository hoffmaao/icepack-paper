\documentclass{article}

\usepackage{amsmath}
%\usepackage{amsfonts}
\usepackage{amsthm}
%\usepackage{amssymb}
%\usepackage{mathrsfs}
%\usepackage{fullpage}
%\usepackage{mathptmx}
%\usepackage[varg]{txfonts}
\usepackage{natbib}
\usepackage{color}
\usepackage[charter]{mathdesign}
\usepackage[pdftex]{graphicx}
%\usepackage{float}
%\usepackage{hyperref}
%\usepackage[modulo, displaymath, mathlines]{lineno}
%\usepackage{setspace}
%\usepackage[titletoc,toc,title]{appendix}

%\linenumbers
%\doublespacing

\theoremstyle{definition}
\newtheorem*{defn}{Definition}
\newtheorem*{exm}{Example}

\theoremstyle{plain}
\newtheorem*{thm}{Theorem}
\newtheorem*{lem}{Lemma}
\newtheorem*{prop}{Proposition}
\newtheorem*{cor}{Corollary}

\newcommand{\argmin}{\text{argmin}}
\newcommand{\ud}{\hspace{2pt}\mathrm{d}}
\newcommand{\bs}{\boldsymbol}
\newcommand{\PP}{\mathsf{P}}

\title{\emph{icepack}: a novel glacier flow modeling package}
\author{Daniel Shapero}
\date{}

\begin{document}

\tableofcontents
\newpage

\maketitle

\begin{abstract}
In this paper we introduce a new software package called \emph{icepack} for modeling the flow of glaciers and ice sheets.
Icepack is built on the finite element modeling library firedrake, which implements the domain-specific language UFL for the specification of weak forms of partial differential equations.
The diagnostic models implemented in icepack use variational formulations that are specified in UFL.
Individual components of each model's action functional can be easily substituted for components of the user's choosing, facilitating experimentation with the model physics.
Additionally, many post-processing and analysis tasks on simulation results amount to the evaluation of some functional.
By using a variational formulation of the model physics, the specification of a problem and the analysis of the solution employ the same conceptual vocabulary.
A third advantage of variational principles is that the action functional itself can be used to define a solver convergence criterion that is independent of the mesh and requires little tuning on the part of the user.
Icepack features a 3D diagnostic model based on terrain-following coordinates and vertical spectral discretization.
This model resolves both plug- and shear-flow components of horizontal ice flow with a minimum of computational expense over 2D, depth-averaged models.
Finally, icepack implements a Gauss-Newton solver for inverse problems that runs substantially faster than the standard BFGS method used in the glaciological literature.
The overall design philosophy of icepack is to enable usability for as wide a swathe of the glaciological community as possible, including both experts and novices in numerical PDE solvers and high-performance computing.
\end{abstract}

\section{Introduction}

Numerical modeling has become an essential part of the workflow of glaciologists across all disciplines.
We highlight four main uses of glacier models in the literature:
\begin{enumerate}
    \item predicting future glacier extent and estimating the sea-level rise contribution from glacier dynamics,
    \item exploring poorly-understood aspects of glacier physics, such as hydrology and calving,
    \item estimating unobservable quantities, such as bed friction or rheology, from observational data, and
    \item reconstructing what glaciers of the near- or distant-past may have looked like.
\end{enumerate}
Nearly all glaciologists, from graduate students to senior researchers, need to use numerical models at some point in their career.
Several glacier flow models already exist and are effective in the hands of experts.
These models are usually written in compiled programming languages such as C, C++, and Fortran, which afford an unsurpassed degree of computational speed.
Many researchers in glaciology, however, receive little or no formal programming training, much less in these languages, and are instead self-taught in either Python or MATLAB.
The ubiquity of C, C++, and Fortran in scientific computing can create a barrier to entry for using numerical models to glaciologists who are not experts in modeling as such.
We wanted to make a tool that would be accessible also to non-experts.

\textcolor{red}{We focus in this paper only on novel aspects of icepack that differ substantially from existing packages.}

The glacier flow modeling package closest in spirit to icepack is VarGlaS \citep{brinkerhoff2013data}.
VarGlaS is implemented using the finite element modeling package FEniCS \citep{logg2012automated}.
The Firedrake project began as an outgrowth of FEniCS and both packages implement the same domain-specific language for specifying weak forms of PDE.
Icepack improves upon the groundwork laid in VarGlaS through its use of tensor product finite elements on extruded meshes, both of which are only available in firedrake \citep{bercea2016structure, mcrae2016automated}.
These two features enable the definition of a much simpler 3D flow model that we will describe in the next section.

The two main components of a glacier flow model are a \emph{diagnostic} and a \emph{prognostic} equation.
The diagnostic equation prescribes the ice velocity through a time-independent, nonlinear, elliptic partial differential equation.
The inputs to the diagnostic equation are the ice thickness, surface elevation, rheology, ice velocity at the inflow boundary, and the coefficient of friction for contact with the bed and side walls.
The output of the diagnostic equation is the ice velocity throughout the entire region of interest.
The prognostic equation prescribes how the ice thickness evolves through conservation of mass.
The inputs to the prognostic equation are the current value of the ice thickness, the ice velocity, and the surface and basal mass balance.
The output is the ice thickness at a later time.
Mathematically, these two coupled PDEs can be thought of as a differential-algebraic equation.

The rheology and friction coefficient may also be described in terms of other fields.
For example, the rheology can be parameterized in terms of the ice temperature, englacial water content, and damage state.
Likewise, the friction coefficient can be described in terms of a geological roughness factor and the subglacial water pressure.
The diagnostic and prognostic equations can then be supplemented with evolution equations for these fields, for example the heat equation for temperature, or a hydrology model for subglacial water pressure.


\section{Diagnostic models}

There are two diagnostic models implemented in icepack.
The \emph{shallow stream approximation} (SSA) is a 2D model describing the depth-averaged velocity of a fast-flowing grounded ice stream or floating ice shelf \citep{macayeal1989large}.
The SSA model is appropriate where the sliding velocity is close to the surface velocity, or in other words where the ice is nearly in plug flow.
Plug flow is a good approximation in fast-flowing ice streams and outlet glaciers near the margins of an ice sheet, but deep in the interior the flow is mostly by vertical shear.
The \emph{first-order} or \emph{Blatter-Pattyn} (BP) approximation, by contrast, is a 3D model describing the horizontal velocity \citep{blatter1995velocity, pattyn2003new}.
The only approximation in the BP model is that the flow has a low aspect ratio -- the thickness of the glacier is much less than its horizontal extent.
This approximation may be questionable around, say, the main trunk of Jakobshavn Isbrae in Greenland, which flows through a very deep and narrow trough.
Even Jakobshavn has an aspect ratio on the order of 1/5 and almost all glacier flows have an aspect ratio less than 1/10 or even 1/20.

Both the SSA and BP models in icepack are described through \emph{action principles} \citep{dukowicz2010consistent}.
Rather than describe the velocity as the weak solution of a nonlinear PDE, an action principle instead states that the velocity minimizes a certain nonlinear functional, called the action.
The action consists of four terms:
\begin{align}
    & \text{action} = \iint\text{stress} \times \text{strain rate}\ud z\ud x - \int\text{basal friction} \times \text{sliding velocity}\ud x \nonumber \\
    & \quad - \iint\text{surface slope}\times\text{velocity}\ud z\ud x - \iint\text{ocean pressure}\times\text{velocity}\ud z\ud \gamma
    \label{action-functional}
\end{align}
where $\ud z\ud x$ denotes integration over the entire glacier, $\ud x$ denotes integration over the glacier footprint, and $\ud z\ud\gamma$ over the side wall boundary.
The action has units of power (energy/time) and can be related to the rate of decrease of the thermodynamic free energy.
Moreover, the energy lost to viscous and frictional heating can be calculated from the action and its Legendre transform.
The action principle can be viewed as a consequence of the Onsager reciprocity relations for systems near to equilibrium \citep{de2013non}.

Irrespective of any deep connections with thermodynamics, the existence of an action principle is a tremendous convenience for numerical analysis.
For viscous flow problems near to steady-state, the action is \emph{convex} as a function of the ice velocity, i.e. its second derivative is positive-definite.
Convexity implies that the action functional has a unique minimizer and that, with an appropriate line search strategy, Newton's method will converge from any initial guess.
Minimizing a convex action functional is vastly more convenient numerically than solving a general nonlinear equation, although the two formulations are equivalent.


\subsection{Implementation with firedrake}

At the highest level, each physics model in icepack is represented by a Python class.
So far, the models available are \texttt{IceShelf}, \texttt{IceStream}, and \texttt{HybridModel}.
Each class has three main responsibilities.
First, the model class has to have a method that takes in the various fields (ice velocity, thickness, surface elevation, etc.) and returns a symbolic representation of the action functional for that particular model.
Second, the model class must have a method that takes in the input fields and returns an approximate minimizer of the action functional.
The diagnostic solve method amounts to invoking an external Newton solve procedure on the symbolic action functional that the first method calculates.
The Newton solver itself is completely standard but the convergence criterion is not and will be discussed in section \S\ref{sec:convergence-criteria}.
Finally the model must have a method to update the ice thickness from the current value, the ice velocity, and the mass balance rates.
The prognostic solver will be discussed in section \S\ref{sec:prognostic-model}.

\textcolor{red}{Some sample code.}

The Unified Form Language for specifying weak forms of PDEs contains all of the primitives necessary to express individual terms of the action functional.
These primitives largely consist of the basic vector calculus operators like the gradient of a field, tensor calculus operations like taking the dot product of two vectors or tensors, scalar functions like the square root or exponential, and symbolic integration over the mesh or its boundary.
For example, the strain rate for a given velocity field $u$ can be written as \texttt{sym(grad(u))}, where the function \texttt{grad} represents the symbolic gradient of a field and \texttt{sym} represents the symmetrization of a rank-2 tensor.

\textcolor{red}{Brief discussion of SSA model.}

The 3D flow model, as represented in the \texttt{HybridModel} class, uses several features that are only available in Firedrake to better exploit the underlying mathematics.
First, rather than represent the 3D physical domain itself, we instead use \emph{terrain-following coordinates} and \emph{extruded meshes}.
The terrain-following vertical coordinate $\zeta$ is defined as
\begin{equation}
    \zeta = \frac{z - b}{h}
\end{equation}
where $b$ is the ice base.
We can then think of the computational domain as the Cartesian product of a 2D footprint domain $\Omega$ and the unit interval $[0, 1]$.

Both the bed elevation and thickness depend on $x$ and $y$.
As a result, the formula for the horizontal gradient of a field in terrain-following coordinates includes an additional geometric correction factor.
Letting $\nabla_z$ and $\nabla_\zeta$ denote the horizontal gradient with respectively $z$ and $\zeta$ held constant, the chain rule gives us that
\begin{equation}
    \nabla_zq = \nabla_\zeta q + \frac{\partial q}{\partial\zeta}\nabla\zeta,
\end{equation}
where we can calculate the spatial gradient of $\zeta$ as
\begin{equation}
    \nabla\zeta = -h^{-1}\left\{(1 - \zeta)\nabla b + \zeta\nabla s\right\}.
\end{equation}
Likewise, the strain rate of a vector field can be expressed as
\begin{equation}
    \dot\varepsilon_z(u) = \dot\varepsilon_\zeta(u) + \frac{1}{2}\left(u \otimes\nabla\zeta + \nabla\zeta\otimes u\right)
\end{equation}
where $\otimes$ is the tensor product of two vectors.
The geometric correction factor can easily be represented in UFL.
By defining a wrapper around the UFL \texttt{grad} function, the code to define the action functional in terrain-following coordinates is no more complex than in Cartesian coordinates.

Terrain-following coordinates are especially advantageous on extruded meshes.
An extruded mesh takes a 2D footprint mesh and lifts it into 3D by taking the Cartesian product with the unit interval.
The cells of an extruded mesh are triangular prisms instead of the more common tetrahedra used for general 3D meshes.
In Firedrake, an extruded mesh is created by calling the function \texttt{ExtrudedMesh} on the 2D footprint.
Not every 3D domain can be described by extruding a 2D domain, but the geometry of most glacier flow problems can.

A 2D mesh can be extruded to any number of vertical layers.
In Elmer/Ice, for example, the user chooses the number of vertical layers in order to set the resolution along this axis \citep{gagliardini2013capabilities}.
The horizontal velocity is expected to be very smooth as a function of depth.
For example, under the plug flow approximation, the horizontal velocity is constant with depth.
Under the shallow ice approximation, the horizontal velocity varies with depth as $1 - (1 - \zeta)^{n + 1}$ where $n = 3$ is the Glen flow law exponent.
This extra information about our solution suggests a different discretization strategy.

Rather than extrude the footprint mesh into many vertical layers, we might instead use only one vertical layer and increase the polynomial degree in the vertical direction only to obtain higher resolution.
To support this use case, Firedrake includes the ability to define \emph{tensor product} elements on extruded meshes.
Given a set of finite element basis functions $\{\phi_k(x, y)\}$ defined on the 2D domain $\Omega$ and a set of basis functions $\{\psi_l(\zeta)\}$ defined on the unit interval $[0, 1]$, the tensor product finite element basis $\{\Phi_{kl}\}$ on the extruded domain is defined as
\begin{equation}
    \Phi_{kl}(x, y, \zeta) = \phi_k(x, y)\psi_l(\zeta).
\end{equation}
For example, we can use piecewise linear or quadratic elements on triangles and use quintic or higher degree polynomials in the vertical.
Tensor product elements are defined in Firedrake by passing the extra keyword arguments \texttt{vfamily}, \texttt{vdegree} to the constructor for a function space.
Rather than use the usual Lagrange interpolating polynomial basis in the vertical dimension, we can instead use the Legendre polynomial basis.
The Legendre polynomials are mutually orthogonal and this choice makes the mass matrix block-diagonal.
To select the Legendre polynomial basis, the user passes the keyword argument \texttt{vfamily=`Gauss-Legendre'} or \texttt{`GL'} for short to the constructor for the function space.

The combination of using extruded meshes and tensor product elements in the vertical direction is referred to as \emph{semi-discretization}.
This approach can be thought of merely as a way to discretize a PDE that has special structure.
Alternatively, we can view vertical semi-discretization as defining a family of models indexed by the number of vertical basis functions.
The order-$d$ model defines a coupled system of PDEs for $d$ vector fields.
Each vector field represents one mode of vertical variability, similar to the distinction between barotropic and baroclinic modes in atmospheric physics and oceanography.
The system is then discretized in the horizontal and solved numerically.
In any case, the code is the same regardless of how one wishes to think about the underlying mathematics.

We are then faced with the choice of how many vertical basis functions to use.
Using only degree 0 is exactly equivalent to the shallow stream approximation and we use this fact as a ``smoke test'' for the hybrid model.
The degree 1 model is the most minimalistic model that still exhibits vertical shear.
Going to higher and higher degree gives a more accurate approximation at the expense of greater computational effort.

This approach for implementing a 3D flow model works completely seamlessly but for one important detail.
The backpressure from ocean water at the calving front of a marine-terminating glacier is not a smooth function of depth.
The pressure is 0 above the water line and linearly increasing below it:
\begin{equation}
    \text{backpressure power} = \int_\Gamma\int_0^1 \rho_Wgh(\zeta_{\text{sl}} - \zeta)_+\ud\zeta\ud\gamma,
    \label{backpressure}
\end{equation}
where $\zeta_{\text{sl}}$ denotes the relative depth to the water line and the subscript $+$ denotes the positive part of a real number.
Were we to use the standard asssembly procedure in Firedrake to evaluate this integral, we would get an inaccurate result due to an insufficient number of integration points.
The resulting velocity solutions are then wildly inaccurate due to the mis-specification of the Neumann boundary condition.
A blunt solution to this problem would be to pass an extra argument to the Firedrake form compiler that specifies a much greater integration accuracy in the vertical for this term.
This fix reduces, but does not eliminate, the errors in the velocities, and it incurs an appreciable computational cost.

We instead implemented a routine that symbolically calculates the Legendre polynomial expansion of the function $(\zeta_{\text{sl}} - \zeta)_+$ with respect to the parameter $\zeta_{\text{sl}}$ using the package SymPy \citep{sympy}.
The symbolic variables for $\zeta$ and $\zeta_{\text{sl}}$ used in the SymPy representation of the polynomial expansion are then substituted for equivalent symbolic variables in Firedrake/UFL using the SymPy object's \texttt{subs} method.
Since the result of this symbolic Legendre polynomial expansion is the same upon every invocation, we can save the effort of recalculating it every time by caching the results.
The Legendre polynomial approximation to this function only converges linearly as the number of coefficients is increased, since the the function is continuous but not smooth, and the approximation exhibits noticeable ringing artifacts \textcolor{red}{figure}.
While the approximation itself is not very accurate, the calculated value of the integral in equation \eqref{backpressure} is exact because of the orthogonality property.
Stated another way, the residuals in the approximation are large, but they integrate to 0 when multiplied by any Legendre polynomial up to the expansion limit.

The exact symbolic integration approach is both faster and more accurate than using a large number of quadrature points.
The same technique could be used to exactly calculate the ocean backpressure for any model, say the full Stokes equations, using terrain-following coordinates together with a Legendre polynomial expansion in the vertical.

For the Stokes equations, transforming the vertical coordinate also circumvents the issue of how to enforce the partial Dirichlet boundary condition $u\cdot \nu = 0$ at the ice base, where $\nu$ is the unit outward normal vector.
This boundary condition is difficult to impose exactly because the unit outward normal vector $\nu$ is defined on mesh faces while the velocity is defined at mesh vertices.
Elmer/Ice uses an ad-hoc procedure to define the unit normal vectors at mesh nodes \citep{gagliardini2013capabilities}.
With a transformation to terrain-following coordinates, we can just set the terrain-following vertical velocity $\omega$ to be 0 at the ice base to impose this boundary condition.

We also argue that answers expressed in terrain-following coordinates are more intuitive in some respects than in Cartesian coordinates.
At the bed of a grounded glacier, the vertical velocity in Cartesian coordinates is
\begin{equation}
    w = -\dot a_b + u\cdot\nabla b.
\end{equation}
Knowing that a model gives a vertical velocity at the base of a glacier of, say, 10 cm/year, the modeler needs to also know the bed slope and sliding velocity.
In other words it is not immediately clear whether the vertical velocity is more a result of basal mass balance or of geometry without more information.
By contrast, the vertical velocity $\omega$ in terrain-following coordinates evaluated at $\zeta = 0$ is completely determined by basal mass balance and ice thickness.

\textcolor{red}{Speed of hybrid model.}
One of the main advantages of this hybrid model is the ease with which a more accurate solution can be bootstrapped from a less accurate solution, since the two fields are defined on exactly the same geometry.
For example, if we only have a very crude initial guess for the solution, we can obtain a degree-1 solution relatively cheaply.
The resulting velocity field is then used as a much more informed initial guess for a degree-5 solution.
\textcolor{red}{Benchmark.}
Since the vertical basis functions are orthogonal, the projection of the degree-1 solution into the degree-5 function space can be calculated by simply copying array elements.
By contrast, if we tried to use the same strategy to bootstrap a solution with a small number of vertical layers to a solution with a larger number of vertical layers, we would also have to interpolate values to the fine layers.

Finally, we note that this approach was first described in \citet{bassis2010hamilton}.
This work focused solely on flowband models and did not consider the problem of how to calculate the power dissipated at the calving front.
Moreover, this work used only the two vertical basis functions $\psi_1(\zeta) = 1$, $\psi_2(\zeta) = 1 - (1 - \zeta)^{n + 1}$, the idea being that the vertical profile can be written as a direct superposition of the plug flow and shallow ice approximation modes.
By contrast, we leave the number of vertical basis functions up to the user.
This flexibility enables the multigrid-type approach described above.


\subsection{Substituting model components}

Many aspects of glacier physics are not completely understood.
For example, the most common description of basal friction assumes that glacier sliding occurs through regelation, in which case the basal shear stress can be written
\begin{equation}
    \tau_b = -C|u|^{\frac{1}{m} - 1}u
\end{equation}
with $m = 3$ \citep{weertman1957sliding}.
Many authors have argued that, in fast-flowing regions of the ice sheet, glacier sliding occurs instead by plastic deformation within the subglacial sediments \citep{tulaczyk2000basal}.
For plastic sliding, the shear stress is dependent on the yield strength of the subglacial sediments and not on the sliding speed, in which case $m = \infty$ would be most appropriate.
Finally, the Schoof sliding law aims to reconcile the two modes of sliding \citep{schoof2005effect}.
Below a critical sliding speed, the shear stress is aymptotic to $|u|^{1/m}$ as in the Weertman sliding law, but above the critical speed the shear stress is independent of the sliding speed.

The Weertman and plastic sliding laws possess the same functional form but differ only in the value of a single scalar parameter $m$.
The Schoof sliding law, on the other hand, has a totally different functional dependence on the velocity.
Several authors, including Schoof, have proposed that the basal shear stress is also a function of the effective pressure $N = \rho gh - p_w$ within the subglacial hydrological system \citep{budd1979empirical, schoof2005effect}.
Implementing these more sophisticated mathematical models would require adding an extra argument to the procedure for solving the diagnostic equation.

One of our goals with icepack is to facilitate experimentation with the model physics.
To support use cases like implementing the Schoof sliding law, it must be possible to completely alter the functional form of a given model physics component.
For uses cases like explicitly adding the dependence of basal shear stress on hydrology, it must also be possible to add entirely new fields to a given model physics component.
In programming terms this amounts to changing the number of arguments to the function that calculates basal shear stress.
For a library developed in C or Fortran, the user would then also have to change the signature of the diagnostic solve function.
In C++ one could obviate the need to modify the diagnostic solve routine by using variadic templates.
But variadic templates are a more advanced language feature and using them would arguably present a steep learning curve for novices.

In icepack, any given model physics component can be substituted for a parameterization of the user's choosing.
Every flow model in icepack is represented by a Python object, and each model object is initialized with a set of functions to calculate the various terms of the action functional.
For example, the ice stream model is initialized with functions to calculate the contributions due to viscosity, basal friction, side wall drag, and gravity.
Sensible parameterizations are selected by default.
If the user does wish to change a given component, they can pass a function that they write to the initializer for the model object.
When the diagnostic solve procedure is invoked, all of its arguments are then passed on by keyword to the method that calculates the action functional.
Any fields that are unnecessary for calculating a given component are simply ignored.
For example, the rheology and friction coefficient are passed to the function that calculates the gravitational driving power, and this function simply makes no use of these arguments.
The functional form can be changed entirely and new arguments can be added, with the only restriction that they are passed as keyword and not as positional arguments.

We are restricted to using keyword arguments instead of positional arguments by adopting this approach.
For the particular case of passing several fields to a physics solver routine, using only keyword arguments enhances readability and comprehensibility.
The user only needs to know the argument names, which are chosen to agree with what symbols are commonly used in the literature -- $C$ for friction, $A$ for rheology, $N$ for effective pressure, etc.
The order of the arguments is arbitrary and immaterial.
For defining, say, the bilinear form that represents a non-symmetric PDE, the order of the arguments has intrinsic mathematical significance and our design would be inappropriate.

One of our main design goals for icepack is to enable users to ``plug and play'' their own physics.
Since many aspects of glacier flow are not understood completely, we view extensibility as an essential requirement for any software package in this domain.
Writing the entire package in Python was necessary to meet this goal.
Many scientific software packages consist of a highly-optimized core library in C, C++, or Fortran, together with a wrapper that exposes this library to an interpreted language like Python.
This approach in principle offers the best of both worlds -- the runtime efficiency of a compiled language with the convenience and interactivity of an interpreted one.
Many practitioners, however, will use such a library entirely through the interpreted surface layer and have no familiarity with the language in which the fast core was written.
These users then have a steep learning curve to overcome when they need to modify functionality that lives in the core library, as they now need to learn an entirely new programming language.
Some low-level kernel code is always necessary for runtime efficiency of course.
With Firedrake, this responsibility is deferred to a code generator of which the average user remains blissfully unaware.


\subsection{Convergence criteria} \label{sec:convergence-criteria}

Calculating the ice velocity from the geometry and other input fields involves minimizing a convex functional.
The minimizer can only be approximated, so we employ iterative procedures based on Newton's method with a line search.
We must then choose some metric to decide when the current guess for the velocity is good enough to stop the iteration.

A convergence criterion that works equally well independent of the mesh, finite element discretization, and the quality of the initial guess can be defined based on the idea of the \emph{Newton decrement} \citep{nocedal2006numerical}.
The search direction $v_k$ at step $k$ for Newton's method is defined as
\begin{equation}
    v_k = -\ud^2J(u_k)^{-1}\ud J(u_k).
\end{equation}
Since the second derivative operator $\ud^2J(u_k)$ is positive-definite, this is a descent direction for the action $J$:
\begin{equation}
    \ud J(u_k)\cdot v_k < 0.
\end{equation}
The absolute value of the quantity in the last equation is defined as the Newton decrement.
For $u_k$ sufficiently close to the true solution $u$, the Newton decrement roughly tells us how much we can expect the action to decrease:
\begin{equation}
    J(u_k) - J(u) \approx \frac{1}{2}|\ud J(u_k)\cdot v_k|.
\end{equation}
We can then use the Newton decrement to decide when to stop the iteration.

As shown in equation \eqref{action-functional}, the action has units of power and is the sum of the dissipation due to viscosity, friction, gravitational driving, and restrain by ocean pressure at the terminus.
The viscous and frictional terms are convex and positive functions of the velocity, while the gravitational and terminus stress terms are linear in the velocity and can be of either sign.
If we define the \emph{scale functional}
\begin{equation}
    K(u) = \text{viscous dissipation} + \text{frictional dissipation}
\end{equation}
as only the positive parts of the action, then the convergence criterion
\begin{equation}
    |\ud J(u_k)\cdot v_k| < \epsilon K(u_k)
\end{equation}
is independent of the discretization.
The intuition behind this criterion is that iteration is halted when the expected decrease in the action functional is much smaller than the positive part of the action itself.

We have found empirically that, with this criterion and the Newton solver implementation in icepack, the iteration usually converges to machine precision in around 8 steps.
For exceptionally bad initial guesses the iteration count can reach as high as 20 but rarely more.
We also observe the expected doubling of the number of accurate digits in the value of the action once the velocity guesses are within the convergence basin of the true solution.
Other convergence criteria, such as using relative change in the velocity guesses, can terminate prematurely when the initial guess is very far outside the quadratic convergence basin.

The numerical solvers in icepack have been designed so that users who are not familiar with numerical optimization need not be confronted with a possibly bewildering array of algorithmic parameters.
Consequently, sensible defaults have been chosen for the Armijo and Wolfe criteria \citep{nocedal2006numerical}, and the tolerance for the line search is chosen based on that of the outer-level Newton iteration.
The Newton search direction is calculated using a direct factorization solver rather than, say, the conjugate gradient algorithm, as the use of another iterative method would introduce yet another algorithmic parameter.
The existing algorithmic parameters can nonetheless be changed from their defaults by passing keyword arguments for advanced users who are interested in performance optimization.


\section{Prognostic model} \label{sec:prognostic-model}

The PDE describing how the ice thickness changes in time is a simple conservative advection equation:
\begin{equation}
    \frac{\partial h}{\partial t} + \nabla\cdot hu = \dot a_s - \dot a_b,
\end{equation}
where $\dot a_s$ and $\dot a_b$ are the surface and basal mass balance.
The thickness is represented using continuous Galerkin basis functions.
The ice thickness and bed elevation are used to update the surface elevation at every timestep, and we need the surface gradient to calculate the driving stress.
The need to calculate gradients of the surface elevation precludes the use of discontinuous Galerkin methods.

The simplest explicit timestepping schemes are unstable with continuous Galerkin finite elements.
Other packages use the streamlined upwind Petrov-Galerkin (SUPG) method for the timestepping scheme \textcolor{red}{cite ISSM, VarGlaS}.
The SUPG method is explicit in time and conditionally stable \textcolor{red}{cite Donea and Huerta?}.
This scheme introduces a tuneable stabilization parameter, so in the interest of simplicity we instead default to the implicit Euler scheme.
The implicit Euler scheme requires solving a more complicated linear system, but the extra computational cost comes with the advantage of unconditional stability.
Practicing glaciologists who have not studied numerical PDE may be unfamiliar with the Courant-Friedrichs-Lewy condition.
The use of an unconditionally stable scheme guarantees that they will get an answer should they try to use a large timestep rather than a runtime error.
The extra cost of using an implicit time discretization for the mass transport equation is dwarfed by the cost of the diagnostic solve in any case.
Advanced users who are interested in maximizing performance can subclass the mass transport solver to implement a faster explicit scheme.

The implicit Euler scheme introduces a large degree of artificial diffusion \textcolor{red}{cite Donea and Huerta}.
Since the ice thickness does not possess shockwaves or propagating discontinuities this error mode is tolerable.
The coupling of ice thickness to velocity makes the whole system more resemble a parabolic problem than a hyperbolic one, and under the shallow ice approximation the system is truly parabolic.
Other problems within glaciology have more of a hyperbolic character and there the argument for using shock-capturing methods is much stronger.
For example, in continuum damage mechanics, the thresholding behavior of the source terms can induce sharp discontinuities in the damage field \textcolor{red}{cite Albrecht and Levermann}.
The implicit Euler scheme would obscure this feature and an alternative method such as the strong stability-preserving Runge Kutta method would be more appropriate.


\section{Data assimilation}

Icepack includes a set of routines for estimating the basal friction or rheology coefficients from observational data.
The class \texttt{InverseProblem} represents the specification of the inverse problem.
To specify an inverse problem, the user must provide:
\begin{itemize}
    \item the model object and the method that solves the diagnostic equation,
    \item the objective and regularization functionals,
    \item the observed field and the name of the argument to the diagnostic solver,
    \item an initial guess for the field to be estimated and the name of the argument to the diagnostic solver,
    \item extra data passed to the diagnostic solver such as boundary conditions.
\end{itemize}
At present, this class assumes that the observed state is always the ice velocity, but in principle the same design would suffice for more complicated inverse problems.
More importantly, the inverse problem is flexible enough to account for the fact that we might have substituted in our own parameterization for the rheology or friction coefficient.
For example, nearly all studies in the literature use an alternate parameterization of these coefficients in terms of some auxiliary field in order to guarantee positivity \textcolor{red}{citations}.
This information is passed to the inverse problem by specifying the names of the keyword arguments for the observed state and the field we wish to observe.

The class \texttt{InverseSolver} is an abstract interface for classes that actually solve the inverse problem.
There are three implementations of this interface in icepack: \texttt{GradientDescentSolver}, \texttt{BFGSSolver}, and \texttt{GaussNewtonSolver}.
All of these classes are based around the general idea of first computing a search direction and then performing a line search in every iteration.
They differ in how the search direction is computed.
The gradient descent solver uses the search direction
\begin{equation}
    \phi_k = -M^{-1}\ud J(\theta_k)
\end{equation}
where $M$ is the finite element mass matrix.
Gradient descent is a popular choice because the objective functional is always decreasing along this search direction.
However, the search direction can be poorly scaled to the physical dimensions of the problem at hand.
This method can be very expensive and brittle in the initial iterations and often takes many steps to converge.
The BFGS method uses the past $m$ iterations of the algorithm to compute a low-rank approximation to the inverse of the objective functional's Hessian matrix; see \citet{nocedal2006numerical} for a more in-depth discussion.
The BFGS method converges faster than gradient descent but suffers from many of the same brittleness issues in the initial iterations before it has accumulated enough history.
Finally, the Gauss-Newton solver defines an approximation to the ``first-order'' part of the objective functional Hessian.
Each iteration of Gauss-Newton is more expensive than that of BFGS or gradient descent because it requires the solution of a more complex linear system than just the mass matrix.
The Gauss-Newton method converges fastest by far in virtually every test case we have found, in some instances by up to factor of 50.

The derivative of the objective functional with respect to the unknown parameter is calculated using the symbolic differentiation features of Firedrake.
The user does not need to provide any routines for the derivatives, only the symbolic form of the error metric and the regularization functional.
The model object is responsible for providing the symbolic form of the action functional.

The bootstrapping approach used to calculate higher-order solutions to the hybrid model from lower-order solutions rather than from a cold initial guess can also be used for inverse problems.
First, we estimate the unknown parameter using only degree-1 vertical basis functions for the velocity field, which captures most of the spatial variability of the unknown parameter.
The resulting coefficient is then used as the initial guess with higher degree vertical basis functions for the velocity \textcolor{red}{benchmark}.


\section{Demonstrations}


\section{Testing}


\section{Usability}


\section{Discussion}

\bibliographystyle{plainnat}
\bibliography{icepack.bib}

\end{document}
